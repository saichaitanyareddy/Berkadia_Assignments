Nginx:
	Nginx is a web server which can also be used as a reverse proxy, load balancer, mail proxy and HTTP cache.
	Reverse Proxy:A reverse proxy is a type of proxy server that retrieves resources on behalf of a client from one or more servers.
	Load Balancer:Load balancing improves distribution of workload among several computing resources.

	HTTP cache:A web cache/HTTP cache is an information technology for the temporary storage of web documents, such as HTML pages and images, to reduce server lag. 
		   A web cache system stores copies of documents passing through it. 
		   The subsequent requests may be satisfied from the cache if certain conditions are met.

	Igor Sysoev began development of Nginx in 2002 to solve C10k problem.
	
	C10K problem:The C10k problem is the problem of optimising network sockets to handle a large number of clients at the same time.[1] The name C10k is a numeronym for concurrently handling ten thousand connections
	Nginx was written with an explicit goal of outperforming the Apache web server.

Apache:
	Apache generally uses PHP as a scripting language, which has been around forever, is stable, and has a lot of support. 
	If you're going to use a CMS like Wordpress, Drupal, or Joomla or really anything PHP-related, you're much better off going with Apache.
	As of August 2018, it was estimated to serve 39% of all active websites and 35% of the top million websites.
	Apache supports a variety of features, many implemented as compiled modules which extend the core functionality.
	Virtual hosting allows one Apache installation to serve many different Web sites.

NodeJs:
	Node.js is a platform built on Chrome's JavaScript runtime for easily building fast and scalable network applications. 
	Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.


Differences:
	Nginx and Node.js can speed up performance and perhaps offer some advantages to concurrent connections.
	These both are asynchronous and evented, so their way of handling processes and requests is fundamentally different from Apache in that respect.
	Apache will try to make new processes, new threads for every requests in every connection.
